# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature stdin
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------


# stdin -- effect providing several features
# for consuming the given byteInputHandler
#
private stdin(
    ip byteInputHandler,
    # action to be taken: plain nomad, install or replace?
    redef r effectMode.val,
    _ unit
  ) : stdins, effect r is


  # read a single byte from stdin
  byte =>
    (stdin ip.next mode unit).ip.get


  # an infinite list of either a byte, an end_of_file or an error
  # Caution!: this list is not immutable since it is constructed lazily by reading from stdin!
  # you may iterate only once.
  # Additionally there may be read more from stdin than what is consumed
  # via this list.
  # NYI: How can we lessen these imperfections?
  bytes list (choice u8 end_of_file error) is
    list byte ()->bytes


  # try reading a codepoint from stdin
  codepoint =>
    read_codepoint(read_bytes list u8) choice error end_of_file codepoint is
      match byte
        byte u8 =>
          bytes := read_bytes ++ [byte]
          match (strings.fromBytes bytes).codepointsAndErrors.first
            c codepoint => c
            e error => if bytes.count >= 4 then e else read_codepoint bytes
        end_of_file => end_of_file
        e error => e

    read_codepoint (lists.empty u8)


  # a - possibly infinite - list of codepoints read from stdin
  # Caution!: this list is not immutable since it is constructed lazily by reading from stdin!
  # you may iterate only once.
  # Additionally there may be read more from stdin than what is consumed
  # via this list.
  # NYI: How can we lessen these imperfections?
  codepoints list codepoint is
    match codepoint
      c codepoint => list c ()->codepoints
      * => nil


  # read n codepoints from stdin
  # may return less than n bytes if end of file is reached
  # or error if stdin can not be read right now
  read(n i32) outcome string
  pre n >= 0
  is
    if n = 0
      ""
    else
      match codepoint
        error error => error
        end_of_file => ""
        c codepoint =>
          match read n-1
            str string => c + str
            error error => error


  # read from stdin until end of line or end of file
  # returns an error if stdin is already depleted = end of file
  # NYI read_line should probably filter carriage returns
  read_line outcome string : character_encodings is
    any_error := mut (choice error nil) nil
    got_end_of_file := mut false

    bytes := streams.generate u8 (() ->
      match byte
        b u8 => if b != ascii.lf then b else nil
        end_of_file end_of_file => got_end_of_file <- true; nil
        error error => any_error <- error; nil)
    #  asArray, since we don't want this to be lazy
      .asArray

    match any_error.get
      error error => error
      * =>
        if got_end_of_file.get & bytes.length = 0
          error "end of file"
        else
          strings.fromBytes bytes


# type to indicate an `end of file`
end_of_file is


# short-hand for accessing stdin effect in current environment
stdin =>
  stdins.installDefault
  stdin.env


# unit feature providing static helpers
stdins is
  installDefault is
    if !effects.exists io.stdin
      s := stdin (defaultInputHandler (error "not initialized")) effectMode.new unit
      s.default


byteInputHandler ref is

  next byteInputHandler is abstract

  # NYI using choice, until open generic for error in outcome is implemented
  get choice u8 end_of_file error is abstract


# the default input handler reading bytes via fuzion.stdin.nextByte
defaultInputHandler(r choice u8 end_of_file error) : byteInputHandler is

  next byteInputHandler is
    v := fuzion.stdin.nextByte
    if v = -1
      defaultInputHandler end_of_file
    else if v < -1
      defaultInputHandler (error "an error occurred while reading stdin")
    else
      defaultInputHandler v.as_u8

  get => r
