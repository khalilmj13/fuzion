# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature has_interval
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# has_interval -- feature for integers that can define an interval
#
public has_interval : integer is

  # defining an integer interval from this to other, both inclusive
  #
  # special cases of interval a..b:
  #
  #   a <  b: the interval from a to b, both inclusive
  #   a == b: the interval containing only one element, a
  #   a >  b: an empty interval
  public infix .. (public upper has_interval.this) : container.Set has_interval.this is

    public lower => has_interval.this


    public size has_interval.this =>
      if lower ≤ upper then
        upper - lower + has_interval.this.type.one
      else
        has_interval.this.type.zero


    # does this interval contain the given value?
    #
    public contains (e has_interval.this) => lower ≤ e ≤ upper


    # Create a Set that is stepping through this interval skipping values. For a
    # non-negative step parameter, the stream will return lower, lower+step,
    # lower+2*step, etc. as long as these values are <= upper.
    #
    # For a negative step parameter, the stream will return lower, lower+step,
    # lower+2*step, etc. as long as these values are >= upper.
    #
    # For a zero step parameter, this will create a Sequence that repeats lower
    # infinitely.
    #
    public infix : (step has_interval.this) : container.Set has_interval.this is


      # list representation of values in this interval
      #
      redef as_list list has_interval.this =>
        if      step.sign = 0                  then [lower].cycle
        else if step.sign > 0 && lower > upper then nil
        else if step.sign < 0 && lower < upper then nil
        else
          tail => (lower+?step ? nil => nil
                               | next has_interval.this => (next .. upper : step).as_list)
          lower : tail


      # does this interval contain the given value?
      #
      public contains (e has_interval.this) =>
        if      step.sign = 0 then lower = e
        else if step.sign > 0 then lower <= e <= upper && (e - lower) %%  step
        else                       lower >= e >= upper && (lower - e) %% -step


    # create a list from this interval
    #
    public redef as_list list has_interval.this =>
      if lower > upper then nil
      else
        tail => (lower+?has_interval.this.type.one ? nil => nil
                                                   | next has_interval.this => (next .. upper).as_list)
        lower : tail


    # string representation of this interval, e.g., "1..10"
    #
    public redef as_string => "$lower..$upper"


  # an infinite integer Sequence starting from this
  #
  public postfix .. : Sequence has_interval.this is

    public lower => has_interval.this


    # does this sequence contain the given value?
    #
    public contains (e has_interval.this) => lower ≤ e


    # Create a Sequence that is stepping through this Sequence skipping values. For a
    # non-negative step parameter, the Sequence will return lower, lower+step,
    # lower+2*step, etc.
    #
    # For a negative step parameter, the Sequence will return lower, lower+step,
    # lower+2*step, etc.
    #
    public infix : (step has_interval.this) : container.Set has_interval.this is


      # list representation of values in this interval
      #
      redef as_list list has_interval.this =>
        tail => (lower+?step ? nil => nil
                             | next has_interval.this => (next .. : step).as_list)
        lower : tail


      # does this Sequence contain the given value?
      #
      public contains (e has_interval.this) =>
        if      step.sign = 0 then lower = e
        else if step.sign > 0 then lower <= e && (e - lower) %%  step
        else                       lower >= e && (lower - e) %% -step


      # string representation of this interval, e.g., "1..10"
      #
      public redef as_string => "$lower.. :$step"


    # create a list from this interval
    #
    public redef as_list list has_interval.this =>
      tail => (lower+?has_interval.this.type.one ? nil => nil
                                                 | next has_interval.this => (next ..).as_list)
      lower : tail


    # string representation of this interval, e.g., "1..10"
    #
    public redef as_string => "$lower.."
