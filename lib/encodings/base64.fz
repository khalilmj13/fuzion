# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature base64
#
# -----------------------------------------------------------------------

# Base64 encoding and decoding as defined in RFC 4648
#
public base64 is

  # allows redefinition for base64url
  module get_alphabet => "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".as_codepoints.as_array
  module encoding_name => "base64"

  # NYI: compiler does currently not optimize features without arguments to treat them like fields
  alphabet := get_alphabet
  char_62_ascii := alphabet[62].utf8.first
  char_63_ascii := alphabet[63].utf8.first

  # Encodes a given byte sequence in base64, output length is padded to multiple of 4
 public encode (data array u8) String =>
   enc24(n u32) => 
                 # extract four sextets from 24 bit number
                 n0 => ((n >> 18) & 63).as_i32
                 n1 => ((n >> 12) & 63).as_i32
                 n2 => ((n >>  6) & 63).as_i32
                 n3 => ( n        & 63).as_i32
                 alphabet[n0] + alphabet[n1] + alphabet[n2] + alphabet[n3]
    for
      res := "", next # the encoded input data
      i := data.indices
      last_n u32 := 0, i %% 3 ?  0 : n
      b in data
      n := (last_n << 8) + b.as_u32
      next := if i%3=2 then enc24 n
              else          res
    else
        case := data.length%3 # last input block of 0, 1 or 2 characters
        if case = 0      then res
        else if case = 1 then res + (enc24 last_n<<4).substring 1 + "=="
        else                  res + (enc24 last_n<<2).substring 2 + "="


  # decodes a base64 string, decoding is strict as required by RFC 4648
  # non alphabet characters, line breaks, missing padding cause errors
  public decode_str(data String) =>
    if data.byte_length != data.codepoint_length
      # check for multi byte unicode chars
      for c in data.as_codepoints
          i in 0..
          res :=
            if (c.byte_length > 1)
              error "character '$c' at position $i is not in $encoding_name alphabet"
            else outcome true
      until !res.ok
        res.err
      else error "this should never happen"

    else
      decode data.utf8.as_array


  # decodes a sequence of ASCII characters, decoding is strict as required by RFC 4648
  # non alphabet characters, line breaks, missing padding cause errors
  public decode(data array u8) =>

    # determine size of padding, i.e. number of '=' (61 in ASCII) at the end
    pad_size :=
      if data.count > 1 && data[data.count - 1] = 61
        if data[data.count - 2] = 61 then 2
        else                              1
      else                                0

    alphabet_check :=
      for b in data
          i:=0, i+1
      do
        check_char :=
          # base64 alphabet character
          if (b >= 65 && b <= 90) || (b >= 97 && b <= 122) || (b >= 48 && b <= 57) || (b = char_62_ascii) || (b = char_63_ascii)
            outcome true

          # padding character =
          else if b = 61
            if i < data.length - pad_size
              error """
                    padding character '=' not allowed within the input data, \
                    only at the very end, as required by RFC464"""
            else outcome true

          # line break
          else if b = 10 || b = 13
              error """
                    line breaks are not allowed within encoded data, as required by RFC464, found \
                    {if b=10 then "LF" else "CR"} at position $i"""
          # other non alphabet character
          else
            error "byte $i in input data, representing '{codepoint b.as_u32}' in ASCII, is not in $encoding_name alphabet"

      until !check_char.ok
        check_char.err
      else outcome true

    if !alphabet_check.ok       # check for non base64 characters
      alphabet_check.err

    else if !(data.length %% 4) # check input length
      error "length of input data is not multiple of four, as required by RFC4648"

    else                        # do decoding

      # replace padding with zeros (character 'A' / 65 is decoded to zero)
      input := (data.map (x -> if x=61 then 65 else x)).as_array

      dec_sextet(input, pos) =>
        n := input[pos]

        if n >= 65 && n <= 90       # case A-Z
          n.as_u32 - 65

        else if n >= 97 && n <= 122 # case a-z
          n.as_u32 - 71

        else if n >= 48 && n <= 57  # case 0-9
          n.as_u32 + 4

        else if n = char_62_ascii   # case +
          u32 62

        else #if n = get_char_63    # case /
          u32 63

      for
        res list u8 := nil, res.concat_sequences [b0, b1, b2] # result: contains the decoded data at the end
        nxt0 := 0, nxt0 + 4
        nxt1 := 1, nxt1 + 4
        nxt2 := 2, nxt2 + 4
        nxt3 := 3, nxt3 + 4
      while nxt3 < input.length
      do
        # convert ascii value into sextets
        sxt0 := dec_sextet input nxt0
        sxt1 := dec_sextet input nxt1
        sxt2 := dec_sextet input nxt2
        sxt3 := dec_sextet input nxt3

        # convert sextets in 24 bit number, break up in three bytes
        block := sxt0 << 18 | sxt1 << 12 | sxt2 << 6 | sxt3
        b0 := (block >> 16).low8bits
        b1 := (block >> 8).low8bits
        b2 := block.low8bits
      else
        # remove zero bytes caused by padding
        outcome res.take(res.count - pad_size)
