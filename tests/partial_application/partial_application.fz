# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test partial_application
#
# -----------------------------------------------------------------------

# this test contains different cases of partial function application
#
partial_application is

  test(msg String, got Any, exp String) =>
    if $got = exp
      say "PASSED: $msg: got '$got'"
    else
      say "FAILED: $msg: got '$got' expected '$exp'"
      _ := set_exit_code 1

  test "map +(1+0)" $([1,2,3,4].map +(1+0)) "[2,3,4,5]"

  o := 1
  t := 2
  test "map +o" $([1,2,3,4].map +o) "[2,3,4,5]"
  test "map -o" $([1,2,3,4].map -o) "[0,1,2,3]"
  test "map o+" $([1,2,3,4].map o+) "[2,3,4,5]"
  test "map o-" $([1,2,3,4].map o-) "[0,-1,-2,-3]"
  test "map *t" $([1,2,3,4].map *t) "[2,4,6,8]"
  test "map %t" $([1,2,3,4].map %t) "[1,0,1,0]"

  qqq(f,g i32->i32) => "{f 42} {g 42}"
  test "qqq lambdas " (qqq x->2*x x->3*x) "84 126"
  test "qqq partials" (qqq    2*     3*)  "84 126"

  data := 1..10
  # NYI:  m := data.map x->2*x; say m   # see #2251, semicolon does not work after lambda
  test "data.map x->2*x    " (data.map x->2*x       ) "[2,4,6,8,10,12,14,16,18,20]"
  test "data.map    2*     " (data.map    2*        ) "[2,4,6,8,10,12,14,16,18,20]"
  test "data.map    *2     " (data.map    *2        ) "[2,4,6,8,10,12,14,16,18,20]"
  test "data.map    2+     " (data.map    2+        ) "[3,4,5,6,7,8,9,10,11,12]"
  test "data.map    +2     " (data.map    +2        ) "[3,4,5,6,7,8,9,10,11,12]"
  test "data.map    2-     " (data.map    2-        ) "[1,0,-1,-2,-3,-4,-5,-6,-7,-8]"
  test "data.map    -2     " (data.map    -2        ) "[-1,0,1,2,3,4,5,6,7,8]"
  test "data.map 3.infix*  " (data.map    3.infix*  ) "[3,6,9,12,15,18,21,24,27,30]"
  test "data.map 3.prefix* " (data.map    3.prefix* ) "[3,6,9,12,15,18,21,24,27,30]"  # NYI: this should not work!
  test "data.map 3.postfix*" (data.map    3.postfix*) "[3,6,9,12,15,18,21,24,27,30]"  # NYI: this should not work!
  test "data.map 4.infix*  " (data.map    4.infix*  ) "[4,8,12,16,20,24,28,32,36,40]"

  i32.prefix      !! => if val <= 1 then 1 else val * !!(val-1)
  integer.postfix !  => if integer.this <= integer.this.type.one then integer.this.type.one else integer.this * (integer.this-integer.this.type.one)!
  i32.postfix !  => if val <= 1 then 1 else val * (val-1)!
  u64.postfix     !!  => if val <= u64 1 then u64 1 else val * (val-1)!!
  u64.prefix      !!  => if val <= u64 1 then u64 1 else val * !!(val-1)

  test "data.map +" (data.map +) "[1,2,3,4,5,6,7,8,9,10]"
  test "data.map -" (data.map -) "[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]"
  test "data.map !!" (data.map !!) "[1,2,6,24,120,720,5040,40320,362880,3628800]"
  test "data.map !" (data.map !) "[1,2,6,24,120,720,5040,40320,362880,3628800]"
  test "((u64 11)..20).map !" (((u64 11)..20).map !) "[39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000]"
#  say (((u64 11)..20).map ! )    # NYI: does not work
#  say (((u64 11)..20).map !!)    # should cause an error: ambiguous prefix and postfix !

  data := [1,2,3,4,5,6,7,8,9,10]  # do not use 1..10 due to #2271
  test "data.zip data x,y->x*y" (data.zip data x,y->x*y) "[1,4,9,16,25,36,49,64,81,100]"
  test "data.zip data +" (data.zip data +) "[2,4,6,8,10,12,14,16,18,20]"
  test "data.zip data *" (data.zip data *) "[1,4,9,16,25,36,49,64,81,100]"

  easy(f i32->i32) =>
    f 42

  test "easy x->x*x   " (easy x->x*x)    "1764"
  test "easy 5.infix* " (easy 5.infix*)  "210"
  test "easy 7*       " (easy 7*)        "294"
  test "easy (7 *)    " (easy (7 *))     "294"
  test "easy 17-      " (easy 17-)       "-25"
  test "easy (17 -)   " (easy (17 -))    "-25"
  test "easy %17      " (easy %17)       "8"
  test "easy (% 17)   " (easy (% 17))    "8"
  test "easy (-(17+0))" (easy (-(17+0))) "25"
  test "easy -(17+0)  " (easy -(17+0)  ) "25"
  test "easy -(17)    " (easy -(17)    ) "25"
  test "easy (- 17)   " (easy (- 17)   ) "25"
  test "easy -17      " (easy -17      ) "25"
  test "easy (+(17+0))" (easy (+(17+0))) "59"
  test "easy +(17+0)  " (easy +(17+0)  ) "59"
  test "easy +(17)    " (easy +(17)    ) "59"
  test "easy (+ 17)   " (easy (+ 17)   ) "59"
  test "easy +17      " (easy +17      ) "59"
  test "easy +o" (easy +o) "43"
  test "easy -o" (easy -o) "41"
  test "easy o+" (easy o+) "43"
  test "easy o-" (easy o-) "-41"
  test "easy *t" (easy *t) "84"
  test "easy %t" (easy %t) "0"

#  x Unary i32 i32 := 5 *

  ambig Unary String i32 => x->"#$x#"
  ambig(x, y i32) String => "$x $y"

  test(f i32->String) => f 32168

#  test ambig          # should cause an error: Ambiguous call to `ambig (3 arguments)` or `ambig (2 arguments)`
#  test (ambig 4711)
  test "test x->(ambig 4711 x)" (test x->(ambig 4711 x)) "4711 32168"

  without_tp =>

    f_0_args                                 => "-"
    f_1_args(a1 i32                        ) => "$a1"
    f_2_args(a1 i32, a2 i32                ) => "$a1,$a2"
    f_3_args(a1 i32, a2 i32, a3 i32        ) => "$a1,$a2,$a3"
    f_4_args(a1 i32, a2 i32, a3 i32, a4 i32) => "$a1,$a2,$a3,$a4"

    fun_arg_with_0_args(f ()               ->String                                ) String => f()
    fun_arg_with_1_args(f  i32             ->String, a1 i32                        ) String => f a1
    fun_arg_with_2_args(f (i32,i32        )->String, a1 i32, a2 i32                ) String => f a1 a2
    fun_arg_with_3_args(f (i32,i32,i32    )->String, a1 i32, a2 i32, a3 i32        ) String => f a1 a2 a3
    fun_arg_with_4_args(f (i32,i32,i32,i32)->String, a1 i32, a2 i32, a3 i32, a4 i32) String => f a1 a2 a3 a4

    test "fun_arg 0 0" (fun_arg_with_0_args  f_0_args            ) "-"
    test "fun arg 0 1" (fun_arg_with_0_args (f_1_args 42        )) "42"
    test "fun arg 0 2" (fun_arg_with_0_args (f_2_args 47 11     )) "47,11"
    test "fun arg 0 3" (fun_arg_with_0_args (f_3_args 32 16 8   )) "32,16,8"
    test "fun arg 0 4" (fun_arg_with_0_args (f_4_args  4  2 0 69)) "4,2,0,69"

    test "fun arg 1 1" (fun_arg_with_1_args  f_1_args 42     )     "42"
    test "fun arg 1 2" (fun_arg_with_1_args (f_2_args 47     ) 11) "47,11"
    test "fun arg 1 3" (fun_arg_with_1_args (f_3_args 32 16  )  8) "32,16,8"
    test "fun arg 1 4" (fun_arg_with_1_args (f_4_args  4  2 0) 69) "4,2,0,69"

    test "fun arg 2 2" (fun_arg_with_2_args (f_2_args     ) 47 11) "47,11"
    test "fun arg 2 3" (fun_arg_with_2_args (f_3_args 32  ) 16  8) "32,16,8"
    test "fun arg 2 4" (fun_arg_with_2_args (f_4_args  4 2)  0 69) "4,2,0,69"

# following line results in crash in fz:
#   test "fun arg 3 3" (fun_arg_with_3_args  f_3_args    32 16  8) "32,16,8"a

    test "fun arg 3 3" (fun_arg_with_3_args  f_3_args    32 16  8) "32,16,8"
    test "fun arg 3 4" (fun_arg_with_3_args (f_4_args 4)  2  0 69) "4,2,0,69"

    test "fun arg 4 4" (fun_arg_with_4_args f_4_args 4 2 0 69) "4,2,0,69"

  without_tp

  with_tp =>

    f_0_args                             => "-"
    f_1_args(a1 T1                     ) => "$a1"
    f_2_args(a1 T1, a2 T2              ) => "$a1,$a2"
    f_3_args(a1 T1, a2 T2, a3 T3       ) => "$a1,$a2,$a3"
    f_4_args(a1 T1, a2 T2, a3 T3, a4 T4) => "$a1,$a2,$a3,$a4"

    fun_arg_with_0_args(f ()           ->R                            ) R => f()
    fun_arg_with_1_args(f  A1          ->R, a1 A1                     ) R => f a1
    fun_arg_with_2_args(f (A1,A2      )->R, a1 A1, a2 A2              ) R => f a1 a2
    fun_arg_with_3_args(f (A1,A2,A3   )->R, a1 A1, a2 A2, a3 A3       ) R => f a1 a2 a3
    fun_arg_with_4_args(f (A1,A2,A3,A4)->R, a1 A1, a2 A2, a3 A3, a4 A4) R => f a1 a2 a3 a4

    test "fun_arg 0 0" (fun_arg_with_0_args  f_0_args            ) "-"
    test "fun arg 0 1" (fun_arg_with_0_args (f_1_args 42        )) "42"
    test "fun arg 0 2" (fun_arg_with_0_args (f_2_args 47 11     )) "47,11"
    test "fun arg 0 3" (fun_arg_with_0_args (f_3_args 32 16 8   )) "32,16,8"
    test "fun arg 0 4" (fun_arg_with_0_args (f_4_args  4  2 0 69)) "4,2,0,69"

    test "fun arg 1 1" (fun_arg_with_1_args  f_1_args 42     )     "42"
    test "fun arg 1 2" (fun_arg_with_1_args (f_2_args 47     ) 11) "47,11"
    test "fun arg 1 3" (fun_arg_with_1_args (f_3_args 32 16  )  8) "32,16,8"
    test "fun arg 1 4" (fun_arg_with_1_args (f_4_args  4  2 0) 69) "4,2,0,69"

    test "fun arg 2 2" (fun_arg_with_2_args (f_2_args     ) 47 11) "47,11"
    test "fun arg 2 3" (fun_arg_with_2_args (f_3_args 32  ) 16  8) "32,16,8"
    test "fun arg 2 4" (fun_arg_with_2_args (f_4_args  4 2)  0 69) "4,2,0,69"

    test "fun arg 3 3" (fun_arg_with_3_args  f_3_args    32 16  8) "32,16,8"
    test "fun arg 3 4" (fun_arg_with_3_args (f_4_args 4)  2  0 69) "4,2,0,69"

    test "fun arg 4 4" (fun_arg_with_4_args f_4_args 4 2 0 69) "4,2,0,69"

  with_tp
