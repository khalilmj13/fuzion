# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test compile_time_type_casts
#
# -----------------------------------------------------------------------

compile_time_type_casts =>

  say ([1,2,3,4,5,6,7,8,9,10].find_first [3,4,5])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [6,7,8])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [1,2,3])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [1,2])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [1])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [2,3,4])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [2,3])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [2])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [8,9,10])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [9,10])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [10])
  say ([1,2,3,4,5,6,7,8,9,10].find_first [5,4,3])  # will fail
  say ([1,2,3,4,5,6,7,8,9,10].find_first [4,3])    # will fail
  say ([1,2,3,4,5,6,7,8,9,10].find_first [3])

  t := ["avenidas",
        "avenidas y flores",
        "flores",
        "flores y mujeres",
        "avenidas",
        "avenidas y mujeres",
        "avenidas y flores y mujeres y",
        "un admirador"]

  say (t.find_first ["avenidas", "avenidas y mujeres"])
  say (t.find_first ["avenidas", "flores y mujeres"])  # will fail
  say (t.find_first ["un admirador"])

  a is
    do_a_thing => say "a!"
  b is
    do_b_thing => say "b!"
  c is
    do_c_thing => say "c!"

  x(v T) =>

    for_String
      pre T : String
    =>
      say "String '$v' type $T len {v.byte_length}"

    if envir.args.count = 3
      # make sure that for the compiler, this may always return as a non-void call
    else if T : String
      say "String '$v' type $T"
      say "String '$v' type $T len {v.byte_length}"
      for_String
    else if T : bool
      # note that `T` is not of type `bool` but of any type that inherits from `bool`. This is why built-in
      # operation like `prefix !`, `infix &&` and `infix ||` that are compiled into `if-then-else` expressions
      # that require the subject to be `bool`will cause an error.
      #
      # NYI: IMPROVEMENT: We might improve this by better error messages or by treating choice type constraints
      # as exact constraints.
      #
      vb := v ^ false
      say "bool $v {type_of(v)} {! vb}"
    else if T : a
      v.do_a_thing
    else if T : b
      v.do_b_thing
    else if T : c
      v.do_c_thing
    else if T : unit
      _ := v
    else
      say "other type $v type $T"

    match T : String
      TRUE  => say "matched String '$v' type $T len {v.byte_length}"; for_String
      FALSE =>

  x "Fuzion!"
  x "F"
  x true
  x nil
  x a
  x b
  x c
  x unit
